#pragma once
#include <iostream>
#include <assert.h>
#include <bgfx/bgfx.h>

namespace vcl::lines {

    struct LinesVertex {
        float X, Y, Z;
        float color;
        float xN, yN, zN;

        LinesVertex(float x, float y, float z, 
                    uint32_t color = COLOR(1, 1, 1, 1), 
                    float xn = 0, float yn = 0, float zn = 0) :
            X(x), Y(y), Z(z),
            color(std::bit_cast<float>(color)),
            xN(xn), yN(yn), zN(zn) {}

        uint32_t getUintColor() const {
            return std::bit_cast<uint32_t>(color);
        }

        float getReverseColor() const {
            uint32_t int_color = getUintColor();

            return std::bit_cast<float>(
                ((int_color & 0xFF000000) >> 24) | 
                ((int_color & 0x00FF0000) >> 8)  |
                ((int_color & 0x0000FF00) << 8)  |
                ((int_color & 0x000000FF) << 24)
            );
        }

        static inline uint32_t COLOR(float r, float g, float b, float a) {
            return static_cast<uint32_t>(
                    (static_cast<uint8_t>(std::round((r) * 255)) << 24) |
                    (static_cast<uint8_t>(std::round((g) * 255)) << 16) |
                    (static_cast<uint8_t>(std::round((b) * 255)) << 8)  | 
                    (static_cast<uint8_t>(std::round((a) * 255)))
                );
        }
    };

    enum LinesTypes {
        CPU_GENERATED       = 0x00000000, // vertex buffer generated by CPU
        GPU_GENERATED       = 0x00000001, // vertex buffer generated by GPU using compute shader
        INSTANCING_BASED    = 0x00000002, // generated lines by instancing buffer
        INDIRECT_BASED      = 0x00000003, // instancing with indirect buffer filled with compute 
        TEXTURE_BASED       = 0x00000004, // instancing with indirect usning text buffer
    };

    enum LinesCaps {
        BUTT_CAP            = 0x00000000, // No extra space on caps
        SQUARE_CAP          = 0x00000001, // Extra space with square shape
        ROUND_CAP           = 0x00000002, // Extra space with round shape
        TRIANGLE_CAP        = 0x00000003  // Extra space with triangle
    };

    enum LinesJoins {
        ROUND_JOIN          = 0x00000000, // Join with round shape
        BEVEL_JOIN          = 0x00000001, // Join with square shape
        MITER_JOIN          = 0x00000002, // Join with a miter
    };

    class LinesSettings {
        private:
            uint8_t m_Thickness;
            uint8_t m_Antialias;
            uint8_t m_Border;
            uint16_t m_ScreenWidth;
            uint16_t m_ScreenHeigth;
            uint32_t m_BorderColor;
            uint8_t m_MiterLimit;

            LinesCaps m_LeftCap;
            LinesCaps m_RigthCap;
            LinesJoins m_Join;

            bgfx::UniformHandle m_UniformData;

        public:
            LinesSettings() = default;

            LinesSettings(uint16_t width, uint16_t heigth) : 
                m_Thickness(5),
                m_Antialias(0),
                m_Border(0),
                m_ScreenWidth(width),
                m_ScreenHeigth(heigth),
                m_BorderColor(LinesVertex::COLOR(0, 0, 0, 1)),
                m_MiterLimit(m_Thickness * 2),
                m_LeftCap(LinesCaps::ROUND_CAP),
                m_RigthCap(LinesCaps::ROUND_CAP),
                m_Join(LinesJoins::ROUND_JOIN)
            {
                m_UniformData = bgfx::createUniform("u_data", bgfx::UniformType::Vec4);
            }

            LinesJoins getJoin() const { return m_Join; }

            void setThickness(uint8_t thickness) { m_Thickness = thickness; }

            void setAntialias(uint8_t antialias) { m_Antialias = antialias; }

            void setBorder(uint8_t border) { m_Border = border; }

            void setScreenSize(uint16_t width, uint16_t heigth) {
                m_ScreenWidth = width;
                m_ScreenHeigth = heigth;
            }

            void setBorderColor(uint32_t borderColor) { m_BorderColor = borderColor; }

            void setMiterLimit(uint8_t miterLimit) {
                if(miterLimit < m_Thickness)
                    assert((void("Miter limit must be greatest then thickness * 2"), false));
                m_MiterLimit = miterLimit;
            }

            void setLeftCap(LinesCaps cap) { m_LeftCap = cap; }

            void setRigthCap(LinesCaps cap) { m_RigthCap = cap; }

            void setJoin(LinesJoins join) { m_Join = join; }

        public:
            void bindUniformLines() const {
                uint32_t screenSize = 0 | m_ScreenWidth << 16 | m_ScreenHeigth;
                uint32_t thickness_antialias_border_caps = ( 
                                                          0 |
                    m_Thickness                       << 24 |
                    m_Antialias                       << 16 |
                    m_Border                          << 8  |
                    static_cast<uint8_t>(m_LeftCap)   << 2  |
                    static_cast<uint8_t>(m_RigthCap)  << 0  
                );
                uint32_t data[] = {screenSize, thickness_antialias_border_caps, m_BorderColor, 0};
                bgfx::setUniform(m_UniformData, data);
            }

            void bindUniformPolylines() const {
                uint32_t screenSize = 0 | m_ScreenWidth << 16 | m_ScreenHeigth;
                uint32_t thickness_antialias_border_miterlimit = ( 
                                                          0 |
                    m_Thickness                       << 24 |
                    m_Antialias                       << 16 |
                    m_Border                          << 8  |
                    m_MiterLimit                      << 0 
                );

                uint32_t caps_join = (                  0 |
                   static_cast<uint8_t>(m_LeftCap)   << 4 |
                   static_cast<uint8_t>(m_RigthCap)  << 2 |
                   static_cast<uint8_t>(m_Join)      << 0  
                );

                uint32_t data[] = {screenSize, thickness_antialias_border_miterlimit, m_BorderColor, caps_join};
                bgfx::setUniform(m_UniformData, data);
            }

    };
}